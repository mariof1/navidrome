package nativeapi

import (
	"context"
	"encoding/json"
	"errors"
	"math"
	"net/http"
	"sort"
	"strconv"
	"time"

	"github.com/Masterminds/squirrel"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/jwtauth/v5"
	"github.com/navidrome/navidrome/log"
	"github.com/navidrome/navidrome/model"
	"github.com/navidrome/navidrome/model/request"
)

func parseISODateSeed(seed string) (string, bool) {
	if seed == "" {
		return "", false
	}
	if _, err := time.Parse("2006-01-02", seed); err != nil {
		return "", false
	}
	return seed, true
}

func syncDailyMixPlaylistsBestEffort(ctx context.Context, ds model.DataStore, seed string, sections []homeRecommendationsSection) {
	defer func() {
		if rec := recover(); rec != nil {
			log.Warn(ctx, "Daily Mix playlist sync panicked", "seed", seed, "recover", rec)
		}
	}()

	seedKey, ok := parseISODateSeed(seed)
	if !ok {
		// Fall back to server-side day key so playlists still appear even if the UI seed changes.
		seedKey = time.Now().UTC().Format("2006-01-02")
	}

	ctxUser := ctx
	usr, ok := request.UserFrom(ctx)
	if !ok || usr.ID == "" {
		// Some handlers may only have the JWT verified but not the user loaded.
		// Try to derive the username from the token and load the user for permission checks.
		token, _, err := jwtauth.FromContext(ctx)
		if err == nil && token != nil {
			username := token.Subject()
			if username != "" {
				u, uerr := ds.User(ctx).FindByUsername(username)
				if uerr == nil && u != nil {
					usr = *u
					ctxUser = request.WithUser(ctx, *u)
				}
			}
		}
	}
	if usr.ID == "" {
		return
	}

	// Build track IDs for each Daily Mix from the section contents.
	// - If the section already contains songs, use them directly.
	// - If it contains albums, expand into songs via a random query.
	trackIDsByMix := map[int][]string{}
	albumIDsByMix := map[int][]string{}
	for _, sec := range sections {
		var idx int
		switch sec.ID {
		case "dailyMix1":
			idx = 1
		case "dailyMix2":
			idx = 2
		case "dailyMix3":
			idx = 3
		default:
			continue
		}

		// Songs-first.
		if sec.Resource == "song" {
			if mfs, ok := sec.Items.(model.MediaFiles); ok {
				ids := make([]string, 0, len(mfs))
				for _, mf := range mfs {
					if mf.ID != "" {
						ids = append(ids, mf.ID)
					}
				}
				trackIDsByMix[idx] = ids
				continue
			}
		}

		// Album fallback.
		if albums, ok := sec.Items.(model.Albums); ok {
			albumIDs := make([]string, 0, len(albums))
			for _, a := range albums {
				if a.ID != "" {
					albumIDs = append(albumIDs, a.ID)
				}
			}
			albumIDsByMix[idx] = albumIDs
		}
	}

	mediaRepo := ds.MediaFile(ctxUser)
	for i := 1; i <= 3; i++ {
		if _, ok := trackIDsByMix[i]; ok {
			continue
		}
		albumIDs := albumIDsByMix[i]
		if len(albumIDs) == 0 {
			trackIDsByMix[i] = nil
			continue
		}

		maxTracks := len(albumIDs) * 10
		if maxTracks < 25 {
			maxTracks = 25
		}
		if maxTracks > 150 {
			maxTracks = 150
		}

		mfs, err := mediaRepo.GetAll(model.QueryOptions{
			Sort:  "random",
			Order: "ASC",
			Max:   maxTracks,
			Seed:  seed + "-pl-dm" + strconv.Itoa(i),
			Filters: squirrel.Eq{
				"album_id": albumIDs,
			},
		})
		if err != nil {
			log.Warn(ctx, "Failed to build Daily Mix playlist tracks", "mix", i, err)
			trackIDsByMix[i] = nil
			continue
		}
		ids := make([]string, 0, len(mfs))
		for _, mf := range mfs {
			if mf.ID != "" {
				ids = append(ids, mf.ID)
			}
		}
		trackIDsByMix[i] = ids
	}

	err := ds.WithTxImmediate(func(tx model.DataStore) error {
		repo := tx.Playlist(ctxUser)
		for i := 1; i <= 3; i++ {
			path := model.DailyMixPlaylistPath(usr.ID, i)
			pls, err := repo.FindByPath(path)
			if err != nil && !errors.Is(err, model.ErrNotFound) {
				return err
			}
			if errors.Is(err, model.ErrNotFound) || pls == nil {
				pls = &model.Playlist{
					Name:    "Daily Mix " + strconv.Itoa(i),
					Comment: "Auto-generated by Navidrome. Updates daily.",
					OwnerID:  usr.ID,
					Public:   false,
					Path:     path,
					Sync:     false,
				}
			}

			// Only refresh at most once per day (based on the ISO seed).
			if pls.UpdatedAt.Format("2006-01-02") != seedKey {
				// Ensure metadata stays consistent even if the playlist existed already.
				pls.Name = "Daily Mix " + strconv.Itoa(i)
				pls.Comment = "Auto-generated by Navidrome. Updates daily."
				pls.Public = false
				pls.Path = path
				pls.OwnerID = usr.ID
				if err := repo.Put(pls); err != nil {
					return err
				}

				tracks := repo.Tracks(pls.ID, false)
				if tracks == nil {
					return model.ErrNotFound
				}
				if err := tracks.DeleteAll(); err != nil {
					return err
				}
				ids := trackIDsByMix[i]
				if len(ids) > 0 {
					if _, err := tracks.Add(ids); err != nil {
						return err
					}
				}
			}
		}
		return nil
	})
	if err != nil {
		log.Warn(ctx, "Failed to sync Daily Mix playlists", "seed", seed, err)
	}
}

type homeRecommendationsResponse struct {
	Sections []homeRecommendationsSection `json:"sections"`
}

type homeRecommendationsSection struct {
	ID       string `json:"id"`
	Resource string `json:"resource"`
	To       string `json:"to"`
	Items    any    `json:"items"`
}

type homeSectionResult struct {
	Items any
	Count int
}

func albumsResult(items model.Albums) homeSectionResult {
	return homeSectionResult{Items: items, Count: len(items)}
}

func songsResult(items model.MediaFiles) homeSectionResult {
	return homeSectionResult{Items: items, Count: len(items)}
}

type homeSectionCandidate struct {
	ID       string
	Resource string
	To       string
	Kind     string
	Build    func() (homeSectionResult, error)
}

func mixTrackLimit(limit int) int {
	// Home UI shows only a single card per bucket, so we can return more items for playback.
	// Keep a reasonable cap to avoid overly large responses.
	if limit <= 0 {
		return 0
	}
	n := limit * 20
	if n < 120 {
		n = 120
	}
	if n > 500 {
		n = 500
	}
	return n
}

func mixAlbumLimit(limit int) int {
	// How many albums to sample to generate a longer song mix.
	if limit <= 0 {
		return 0
	}
	n := limit * 3
	if n < 24 {
		n = 24
	}
	if n > 60 {
		n = 60
	}
	return n
}

func buildSongMixFromAlbums(songRepo model.MediaFileRepository, albums model.Albums, maxTracks int, seed string, excludedSongIDs map[string]struct{}) (model.MediaFiles, error) {
	if maxTracks <= 0 || len(albums) == 0 {
		return nil, nil
	}
	albumIDs := make([]string, 0, len(albums))
	seenAlbum := map[string]struct{}{}
	for _, a := range albums {
		if a.ID == "" {
			continue
		}
		if _, ok := seenAlbum[a.ID]; ok {
			continue
		}
		seenAlbum[a.ID] = struct{}{}
		albumIDs = append(albumIDs, a.ID)
	}
	if len(albumIDs) == 0 {
		return nil, nil
	}

	poolMax := maxTracks
	if poolMax < 200 {
		poolMax = 200
	}
	if poolMax > 2000 {
		poolMax = 2000
	}

	pool, err := songRepo.GetAll(model.QueryOptions{
		Sort:  "random",
		Order: "ASC",
		Max:   poolMax,
		Seed:  seed,
		Filters: squirrel.And{
			squirrel.Eq{"album_id": albumIDs},
			squirrel.Eq{"missing": false},
		},
	})
	if err != nil {
		return nil, err
	}

	out := make(model.MediaFiles, 0, min(maxTracks, len(pool)))
	seenSong := make(map[string]struct{}, maxTracks)
	for _, s := range pool {
		if len(out) >= maxTracks {
			break
		}
		if s.ID == "" {
			continue
		}
		if _, ok := excludedSongIDs[s.ID]; ok {
			continue
		}
		if _, ok := seenSong[s.ID]; ok {
			continue
		}
		seenSong[s.ID] = struct{}{}
		out = append(out, s)
	}
	return out, nil
}

func overfetchMax(limit int) int {
	if limit <= 0 {
		return 0
	}
	max := limit * 5
	if max < limit {
		max = limit
	}
	if max > 200 {
		max = 200
	}
	return max
}

func albumScoreForMix(a model.Album, now time.Time) float64 {
	// Higher is better. This is intentionally simple (and explainable):
	// - Big boost for never-played albums
	// - Prefer albums not played recently
	// - Small familiarity boost for higher play counts
	neverPlayedBoost := 0.0
	if a.PlayCount == 0 {
		neverPlayedBoost = 1000
	}

	daysSincePlay := 0.0
	if a.PlayDate != nil {
		daysSincePlay = now.Sub(*a.PlayDate).Hours() / 24
		if daysSincePlay < 0 {
			daysSincePlay = 0
		}
		// Cap so ancient plays don't dominate too much.
		if daysSincePlay > 365 {
			daysSincePlay = 365
		}
	} else {
		// Treat unknown/never as "very old" without overpowering the never-played boost.
		daysSincePlay = 90
	}

	familiarity := math.Log1p(float64(a.PlayCount)) * 8
	return neverPlayedBoost + (daysSincePlay * 4) + familiarity
}

func selectDiverseAlbums(candidates model.Albums, limit int, now time.Time, excluded map[string]struct{}, maxPerArtist int, requiredArtistIDs []string) model.Albums {
	if limit <= 0 || len(candidates) == 0 {
		return nil
	}
	if maxPerArtist <= 0 {
		maxPerArtist = limit
	}

	// De-dupe and apply exclusions.
	seen := make(map[string]struct{}, len(candidates))
	filtered := make(model.Albums, 0, len(candidates))
	for _, a := range candidates {
		if a.ID == "" {
			continue
		}
		if _, ok := excluded[a.ID]; ok {
			continue
		}
		if _, ok := seen[a.ID]; ok {
			continue
		}
		seen[a.ID] = struct{}{}
		filtered = append(filtered, a)
	}
	if len(filtered) == 0 {
		return nil
	}

	scores := make(map[string]float64, len(filtered))
	for _, a := range filtered {
		scores[a.ID] = albumScoreForMix(a, now)
	}

	// Sort best-first. Candidate order is already pseudo-random due to DB seed;
	// this turns that random sample into a more relevant mix.
	sort.SliceStable(filtered, func(i, j int) bool {
		return scores[filtered[i].ID] > scores[filtered[j].ID]
	})

	artistKey := func(a model.Album) string {
		if a.AlbumArtistID != "" {
			return a.AlbumArtistID
		}
		// Fallback to keep compilations from being overly constrained.
		return a.ID
	}

	add := func(out *model.Albums, artistCounts map[string]int, picked map[string]struct{}, a model.Album, capPerArtist int) bool {
		if len(*out) >= limit {
			return false
		}
		if _, ok := picked[a.ID]; ok {
			return false
		}
		k := artistKey(a)
		if artistCounts[k] >= capPerArtist {
			return false
		}
		picked[a.ID] = struct{}{}
		artistCounts[k]++
		*out = append(*out, a)
		return true
	}

	out := make(model.Albums, 0, min(limit, len(filtered)))
	picked := make(map[string]struct{}, limit)
	artistCounts := make(map[string]int, limit)

	// First pass: ensure coverage of required seed artists (if possible).
	if len(requiredArtistIDs) > 0 {
		need := make(map[string]struct{}, len(requiredArtistIDs))
		for _, id := range requiredArtistIDs {
			if id != "" {
				need[id] = struct{}{}
			}
		}
		for _, req := range requiredArtistIDs {
			if _, ok := need[req]; !ok {
				continue
			}
			for _, a := range filtered {
				if a.AlbumArtistID != req {
					continue
				}
				if add(&out, artistCounts, picked, a, maxPerArtist) {
					delete(need, req)
					break
				}
			}
		}
	}

	// Second pass: fill respecting the per-artist cap.
	for _, a := range filtered {
		if len(out) >= limit {
			break
		}
		add(&out, artistCounts, picked, a, maxPerArtist)
	}

	// Final pass: if we still couldn't fill, relax the cap.
	if len(out) < limit {
		for _, a := range filtered {
			if len(out) >= limit {
				break
			}
			add(&out, artistCounts, picked, a, limit)
		}
	}

	return out
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func (api *Router) addRecommendationsRoute(r chi.Router) {
	r.Get("/recommendations/home", api.getHomeRecommendations())
}

func (api *Router) getHomeRecommendations() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		limit := 12
		if v := r.URL.Query().Get("limit"); v != "" {
			if n, err := strconv.Atoi(v); err == nil && n > 0 && n <= 50 {
				limit = n
			}
		}
		seed := r.URL.Query().Get("seed")

		now := time.Now().UTC()
		onRepeatCutoff := now.AddDate(0, 0, -14)
		rediscoverCutoff := now.AddDate(0, 0, -30)
		inspiredByCutoff := now.AddDate(0, 0, -7)
		continueListeningCutoff := now.AddDate(0, 0, -3)

		albumRepo := api.ds.Album(r.Context())
		songRepo := api.ds.MediaFile(r.Context())
		excludedMixAlbumIDs := map[string]struct{}{}
		excludedMixSongIDs := map[string]struct{}{}

		// Derive a small set of “seed” artists from the user's recent listening patterns.
		// Prefer user_events-derived scoring if available; fallback to play_count/play_date.
		seedArtistIDs, err := api.ds.UserEvent(r.Context()).TopAlbumArtistIDs(6, now)
		if err != nil {
			log.Trace(r.Context(), "Error retrieving top album artists", err)
			seedArtistIDs = nil
		}
		if len(seedArtistIDs) == 0 {
			seenArtists := map[string]struct{}{}
			appendArtists := func(albums model.Albums) {
				for _, a := range albums {
					if a.AlbumArtistID == "" {
						continue
					}
					if _, ok := seenArtists[a.AlbumArtistID]; ok {
						continue
					}
					seenArtists[a.AlbumArtistID] = struct{}{}
					seedArtistIDs = append(seedArtistIDs, a.AlbumArtistID)
				}
			}

			onRepeatSeed, err := albumRepo.GetAll(model.QueryOptions{
				Sort:  "play_count",
				Order: "DESC",
				Max:   limit,
				Filters: squirrel.And{
					squirrel.Gt{"play_count": 0},
					squirrel.GtOrEq{"play_date": onRepeatCutoff},
				},
			})
			if err != nil {
				log.Error(r.Context(), "Error building home recommendations", "section", "onRepeat", err)
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}

			recentlyPlayedSeed, err := albumRepo.GetAll(model.QueryOptions{
				Sort:    "play_date",
				Order:   "DESC",
				Max:     limit,
				Filters: squirrel.Gt{"play_count": 0},
			})
			if err != nil {
				log.Error(r.Context(), "Error building home recommendations", "section", "recentlyPlayed", err)
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}

			mostPlayedSeed, err := albumRepo.GetAll(model.QueryOptions{
				Sort:    "play_count",
				Order:   "DESC",
				Max:     limit,
				Filters: squirrel.Gt{"play_count": 0},
			})
			if err != nil {
				log.Error(r.Context(), "Error building home recommendations", "section", "mostPlayed", err)
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}

			appendArtists(onRepeatSeed)
			appendArtists(recentlyPlayedSeed)
			appendArtists(mostPlayedSeed)
		}

		mix1IDs := seedArtistIDs
		if len(mix1IDs) > 3 {
			mix1IDs = mix1IDs[:3]
		}
		mix2IDs := []string{}
		if len(seedArtistIDs) > 3 {
			mix2IDs = seedArtistIDs[3:]
			if len(mix2IDs) > 3 {
				mix2IDs = mix2IDs[:3]
			}
		}

		dailyMix1Filters := squirrel.Sqlizer(nil)
		if len(mix1IDs) > 0 {
			dailyMix1Filters = squirrel.Eq{"album_artist_id": mix1IDs}
		}
		dailyMix1Seed := seed + "-dm1"

		dailyMix2Filters := squirrel.Sqlizer(nil)
		if len(mix2IDs) > 0 {
			dailyMix2Filters = squirrel.Eq{"album_artist_id": mix2IDs}
		}
		dailyMix2Seed := seed + "-dm2"

		dailyMix3Seed := seed + "-dm3"

		// Candidate bucket builders. We build only the chosen buckets (curated) to avoid
		// flooding the UI and to keep the endpoint efficient.
		candidates := []homeSectionCandidate{
			{
				ID:       "dailyMix1",
				Resource: "song",
				To:       "",
				Kind:     "mix",
				Build: func() (homeSectionResult, error) {
					albumLimit := mixAlbumLimit(limit)
					trackLimit := mixTrackLimit(limit)
					poolMax := overfetchMax(albumLimit)
					maxPerArtist := 2
					requiredArtists := []string(nil)
					filters := dailyMix1Filters
					if len(mix1IDs) > 0 {
						maxPerArtist = int(math.Ceil(float64(albumLimit) / float64(len(mix1IDs))))
						if maxPerArtist < 2 {
							maxPerArtist = 2
						}
						requiredArtists = mix1IDs
					} else {
						// Cold-start fallback: build a general-purpose mix.
						filters = squirrel.Or{
							squirrel.Expr("play_date IS NULL"),
							squirrel.Lt{"play_date": rediscoverCutoff},
							squirrel.Eq{"play_count": 0},
						}
					}
					pool, err := albumRepo.GetAll(model.QueryOptions{
						Sort:    "random",
						Order:   "ASC",
						Max:     poolMax,
						Seed:    dailyMix1Seed,
						Filters: filters,
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					pickedAlbums := selectDiverseAlbums(pool, albumLimit, now, excludedMixAlbumIDs, maxPerArtist, requiredArtists)
					songs, err := buildSongMixFromAlbums(songRepo, pickedAlbums, trackLimit, dailyMix1Seed+"-songs", excludedMixSongIDs)
					if err != nil {
						return homeSectionResult{}, err
					}
					if len(songs) == 0 {
						// Retry without exclusions if we filtered everything.
						songs, err = buildSongMixFromAlbums(songRepo, pickedAlbums, trackLimit, dailyMix1Seed+"-songs2", map[string]struct{}{})
						if err != nil {
							return homeSectionResult{}, err
						}
					}
					return songsResult(songs), nil
				},
			},
			{
				ID:       "dailyMix2",
				Resource: "song",
				To:       "",
				Kind:     "mix",
				Build: func() (homeSectionResult, error) {
					albumLimit := mixAlbumLimit(limit)
					trackLimit := mixTrackLimit(limit)
					poolMax := overfetchMax(albumLimit)
					filters := dailyMix2Filters
					requiredArtists := mix2IDs
					maxPerArtist := 2
					if len(mix2IDs) > 0 {
						maxPerArtist = int(math.Ceil(float64(albumLimit) / float64(len(mix2IDs))))
						if maxPerArtist < 2 {
							maxPerArtist = 2
						}
					} else {
						// If we don't have enough distinct seed artists, still show the bucket with a
						// general mix (different seed keeps it distinct from dailyMix1/3).
						requiredArtists = nil
						filters = squirrel.Or{
							squirrel.Expr("play_date IS NULL"),
							squirrel.Lt{"play_date": rediscoverCutoff},
							squirrel.Eq{"play_count": 0},
						}
					}

					pool, err := albumRepo.GetAll(model.QueryOptions{
						Sort:    "random",
						Order:   "ASC",
						Max:     poolMax,
						Seed:    dailyMix2Seed,
						Filters: filters,
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					pickedAlbums := selectDiverseAlbums(pool, albumLimit, now, excludedMixAlbumIDs, maxPerArtist, requiredArtists)
					if len(pickedAlbums) == 0 {
						pickedAlbums = selectDiverseAlbums(pool, albumLimit, now, map[string]struct{}{}, maxPerArtist, requiredArtists)
					}
					songs, err := buildSongMixFromAlbums(songRepo, pickedAlbums, trackLimit, dailyMix2Seed+"-songs", excludedMixSongIDs)
					if err != nil {
						return homeSectionResult{}, err
					}
					if len(songs) == 0 {
						songs, err = buildSongMixFromAlbums(songRepo, pickedAlbums, trackLimit, dailyMix2Seed+"-songs2", map[string]struct{}{})
						if err != nil {
							return homeSectionResult{}, err
						}
					}
					if len(songs) == 0 {
						// Last-resort fallback: pick albums from the whole library.
						fallbackPool, err := albumRepo.GetAll(model.QueryOptions{
							Sort:  "random",
							Order: "ASC",
							Max:   poolMax,
							Seed:  dailyMix2Seed + "-fallback",
						})
						if err != nil {
							return homeSectionResult{}, err
						}
						fallbackAlbums := selectDiverseAlbums(fallbackPool, albumLimit, now, excludedMixAlbumIDs, 2, nil)
						if len(fallbackAlbums) == 0 {
							fallbackAlbums = selectDiverseAlbums(fallbackPool, albumLimit, now, map[string]struct{}{}, 2, nil)
						}
						songs, err = buildSongMixFromAlbums(songRepo, fallbackAlbums, trackLimit, dailyMix2Seed+"-songs-fb", excludedMixSongIDs)
						if err != nil {
							return homeSectionResult{}, err
						}
						if len(songs) == 0 {
							songs, err = buildSongMixFromAlbums(songRepo, fallbackAlbums, trackLimit, dailyMix2Seed+"-songs-fb2", map[string]struct{}{})
							if err != nil {
								return homeSectionResult{}, err
							}
						}
					}
					return songsResult(songs), nil
				},
			},
			{
				ID:       "dailyMix3",
				Resource: "song",
				To:       "",
				Kind:     "mix",
				Build: func() (homeSectionResult, error) {
					albumLimit := mixAlbumLimit(limit)
					trackLimit := mixTrackLimit(limit)
					poolMax := overfetchMax(albumLimit)
					pool, err := albumRepo.GetAll(model.QueryOptions{
						Sort:  "random",
						Order: "ASC",
						Max:   poolMax,
						Seed:  dailyMix3Seed,
						Filters: squirrel.Or{
							squirrel.Expr("play_date IS NULL"),
							squirrel.Lt{"play_date": rediscoverCutoff},
							squirrel.Eq{"play_count": 0},
						},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					pickedAlbums := selectDiverseAlbums(pool, albumLimit, now, excludedMixAlbumIDs, 2, nil)
					if len(pickedAlbums) == 0 {
						pickedAlbums = selectDiverseAlbums(pool, albumLimit, now, map[string]struct{}{}, 2, nil)
					}
					songs, err := buildSongMixFromAlbums(songRepo, pickedAlbums, trackLimit, dailyMix3Seed+"-songs", excludedMixSongIDs)
					if err != nil {
						return homeSectionResult{}, err
					}
					if len(songs) == 0 {
						songs, err = buildSongMixFromAlbums(songRepo, pickedAlbums, trackLimit, dailyMix3Seed+"-songs2", map[string]struct{}{})
						if err != nil {
							return homeSectionResult{}, err
						}
					}
					if len(songs) == 0 {
						fallbackPool, err := albumRepo.GetAll(model.QueryOptions{
							Sort:  "random",
							Order: "ASC",
							Max:   poolMax,
							Seed:  dailyMix3Seed + "-fallback",
						})
						if err != nil {
							return homeSectionResult{}, err
						}
						fallbackAlbums := selectDiverseAlbums(fallbackPool, albumLimit, now, excludedMixAlbumIDs, 2, nil)
						if len(fallbackAlbums) == 0 {
							fallbackAlbums = selectDiverseAlbums(fallbackPool, albumLimit, now, map[string]struct{}{}, 2, nil)
						}
						songs, err = buildSongMixFromAlbums(songRepo, fallbackAlbums, trackLimit, dailyMix3Seed+"-songs-fb", excludedMixSongIDs)
						if err != nil {
							return homeSectionResult{}, err
						}
						if len(songs) == 0 {
							songs, err = buildSongMixFromAlbums(songRepo, fallbackAlbums, trackLimit, dailyMix3Seed+"-songs-fb2", map[string]struct{}{})
							if err != nil {
								return homeSectionResult{}, err
							}
						}
					}
					return songsResult(songs), nil
				},
			},
			{
				ID:       "inspiredBy",
				Resource: "song",
				To:       "",
				Kind:     "mix",
				Build: func() (homeSectionResult, error) {
					if len(seedArtistIDs) == 0 {
						return homeSectionResult{}, nil
					}
					albumLimit := mixAlbumLimit(limit)
					trackLimit := mixTrackLimit(limit)
					poolMax := overfetchMax(albumLimit)
					artistIDs := seedArtistIDs
					if len(artistIDs) > 2 {
						artistIDs = artistIDs[:2]
					}
					pool, err := albumRepo.GetAll(model.QueryOptions{
						Sort:  "random",
						Order: "ASC",
						Max:   poolMax,
						Seed:  seed + "-inspired",
						Filters: squirrel.And{
							squirrel.Eq{"album_artist_id": artistIDs},
							squirrel.Or{
								squirrel.Expr("play_date IS NULL"),
								squirrel.Lt{"play_date": inspiredByCutoff},
							},
						},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					maxPerArtist := int(math.Ceil(float64(albumLimit) / float64(len(artistIDs))))
					if maxPerArtist < 2 {
						maxPerArtist = 2
					}
					pickedAlbums := selectDiverseAlbums(pool, albumLimit, now, excludedMixAlbumIDs, maxPerArtist, artistIDs)
					songs, err := buildSongMixFromAlbums(songRepo, pickedAlbums, trackLimit, (seed+"-inspired")+"-songs", excludedMixSongIDs)
					if err != nil {
						return homeSectionResult{}, err
					}
					if len(songs) == 0 {
						songs, err = buildSongMixFromAlbums(songRepo, pickedAlbums, trackLimit, (seed+"-inspired")+"-songs2", map[string]struct{}{})
						if err != nil {
							return homeSectionResult{}, err
						}
					}
					return songsResult(songs), nil
				},
			},
			{
				ID:       "continueListening",
				Resource: "album",
				To:       "",
				Kind:     "history",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{
						Sort:  "play_date",
						Order: "DESC",
						Max:   limit,
						Filters: squirrel.And{
							squirrel.Gt{"play_count": 0},
							squirrel.GtOrEq{"play_date": continueListeningCutoff},
						},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
			{
				ID:       "recentlyPlayed",
				Resource: "album",
				To:       "/album/recentlyPlayed?sort=play_date&order=DESC&filter={\"recently_played\":true}",
				Kind:     "history",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{
						Sort:    "play_date",
						Order:   "DESC",
						Max:     limit,
						Filters: squirrel.Gt{"play_count": 0},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
			{
				ID:       "starred",
				Resource: "album",
				To:       "/album/starred?sort=starred_at&order=DESC&filter={\"starred\":true}",
				Kind:     "favorites",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{
						Sort:    "starred_at",
						Order:   "DESC",
						Max:     limit,
						Filters: squirrel.Gt{"starred": 0},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
			{
				ID:       "forgottenFavorites",
				Resource: "album",
				To:       "",
				Kind:     "favorites",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{
						Sort:  "starred_at",
						Order: "DESC",
						Max:   limit,
						Filters: squirrel.And{
							squirrel.Gt{"starred": 0},
							squirrel.Or{squirrel.Expr("play_date IS NULL"), squirrel.Lt{"play_date": rediscoverCutoff}},
						},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
			{
				ID:       "recentlyAdded",
				Resource: "album",
				To:       "/album/recentlyAdded?sort=recently_added&order=DESC&filter={}",
				Kind:     "library",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{Sort: "recently_added", Order: "DESC", Max: limit})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
			{
				ID:       "newReleases",
				Resource: "album",
				To:       "",
				Kind:     "library",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{
						Sort:    "max_year",
						Order:   "DESC",
						Max:     limit,
						Filters: squirrel.Gt{"max_year": 0},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
			{
				ID:       "topRated",
				Resource: "album",
				To:       "",
				Kind:     "rated",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{
						Sort:    "rated_at",
						Order:   "DESC",
						Max:     limit,
						Filters: squirrel.Gt{"rating": 0},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
			{
				ID:       "mostPlayed",
				Resource: "album",
				To:       "/album/mostPlayed?sort=play_count&order=DESC&filter={\"recently_played\":true}",
				Kind:     "history",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{
						Sort:    "play_count",
						Order:   "DESC",
						Max:     limit,
						Filters: squirrel.Gt{"play_count": 0},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
			{
				ID:       "onRepeat",
				Resource: "album",
				To:       "",
				Kind:     "history",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{
						Sort:  "play_count",
						Order: "DESC",
						Max:   limit,
						Filters: squirrel.And{
							squirrel.Gt{"play_count": 0},
							squirrel.GtOrEq{"play_date": onRepeatCutoff},
						},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
			{
				ID:       "rediscover",
				Resource: "album",
				To:       "",
				Kind:     "history",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{
						Sort:  "play_count",
						Order: "DESC",
						Max:   limit,
						Filters: squirrel.And{
							squirrel.Gt{"play_count": 0},
							squirrel.Lt{"play_date": rediscoverCutoff},
						},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
			{
				ID:       "discoverFresh",
				Resource: "album",
				To:       "",
				Kind:     "discovery",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{
						Sort:  "recently_added",
						Order: "DESC",
						Max:   limit,
						Filters: squirrel.And{
							squirrel.Eq{"play_count": 0},
						},
					})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
			{
				ID:       "random",
				Resource: "album",
				To:       "/album/random?sort=random&order=ASC&filter={}",
				Kind:     "discovery",
				Build: func() (homeSectionResult, error) {
					items, err := albumRepo.GetAll(model.QueryOptions{Sort: "random", Order: "ASC", Max: limit, Seed: seed})
					if err != nil {
						return homeSectionResult{}, err
					}
					return albumsResult(items), nil
				},
			},
		}

		// Return all non-empty recommendation sections.
		// Keep a stable ordering (as declared in candidates) so daily mixes stay grouped.
		sections := make([]homeRecommendationsSection, 0, len(candidates))
		for _, cand := range candidates {
			res, err := cand.Build()
			if err != nil {
				log.Error(r.Context(), "Error building home recommendations", "section", cand.ID, err)
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
			if res.Count == 0 {
				continue
			}
			if cand.Kind == "mix" {
				switch v := res.Items.(type) {
				case model.Albums:
					for _, a := range v {
						if a.ID != "" {
							excludedMixAlbumIDs[a.ID] = struct{}{}
						}
					}
				case model.MediaFiles:
					for _, s := range v {
						if s.ID != "" {
							excludedMixSongIDs[s.ID] = struct{}{}
						}
						if s.AlbumID != "" {
							excludedMixAlbumIDs[s.AlbumID] = struct{}{}
						}
					}
				}
			}
			sections = append(sections, homeRecommendationsSection{ID: cand.ID, Resource: cand.Resource, To: cand.To, Items: res.Items})
		}

		resp := homeRecommendationsResponse{Sections: sections}

		// Best-effort: keep Daily Mix playlists synced for the logged-in user.
		syncDailyMixPlaylistsBestEffort(r.Context(), api.ds, seed, sections)

		w.Header().Set("Content-Type", "application/json")
		enc := json.NewEncoder(w)
		if err := enc.Encode(resp); err != nil {
			log.Error(r.Context(), "Error encoding home recommendations", err)
		}
	}
}
